SMACSS: Notes on Usage

---

Intro

Since probably about January of this year, I have been mildly obsessed with the idea of modular CSS. Given that I am a graphic designer by education, I subscribe to modernist ideology gifted to us by Swiss Design and the Bauhaus School where the initial concepts of modularity where born. As I have made the transition from print to web, I remain faithful to thos same ideologies and try to invoke them into web design wherever possible, be it interface mockups or front-end code. When applied correclty, SMACSS greatly satisfies my modernist longings while providing a much cleaner code base.

Research

This article will build off of the existing documentation provided in Jonathan Snook's book "SMACSS: Scalable and Modular Architecture for CSS" and makes the assumption that you have read it. I will go over a brief refresher of its integral talking points and expand on areas or situations that weren't necessarily covered in the book. The assumption is also made that you have a decent working knowledge of CSS, but you do not have to be an expert (I'm not ;-) ). I would highly recommend that you also check out Nicole Sullivan's OOCSS, BEM by Yandex, and the presentation (audio and slides) given by Andy Hume at SXSW: 2012. These are wonderful resources that will only help to expand your understanding of modular CSS and this article will include references to them where appropriate.

SMACSS Intro

SMACSS is an acronym for Scalable and Modular Architecture for Cascading Style Sheets. It is not a framework, but an approach to code methodologies. In it, the primary points that define this approach are: Categorizing CSS Rules, Naming Conventions, and Depth of Applicability. From my experience with this approach, once you have these three points down, it is smooth sailing.

Categorizing CSS Rules

SMACSS places CSS rules into five main categories:

1. Base
2. Layout
3. Modules
4. State
5. Theme

Base Rules are the default. This is where you will put any element selector declarations or CSS resets. You may find that as you move along the process of an actual site build that you are moving frequently repeated styles to the Base styles. That's good! Doing so will limit actual classes or ids (I avoid id selectors for CSS) needing to be applied to the desired element. The caveat is to treat those styles gingerly and to avoid using complex selectors (we'll get into that in Depth of Applicability).

Layout Rules are any styles that dictate major layout components, dividing the page into sections and holding one or more modules together. Wrappers, rows, columns and any grid-based styles should be here. Also major semantic areas as well, such as header, content and footer.

Module Rules make up the bulk of any project. They dictate minor layout components such as callouts, calls-to-action, sidebars, and so on. They should be named in a way that is independent of the page context, making them reusable throughout the site. This is the main point of SMACSS.

State Rules address appearance of a module in it's various states which are not already addressed in CSS. In other words, :hover and :active are already styled via standard CSS syntax, but you may need an additional "current" state for a navigation item showing that the user is currently on that page. States also address how a module may appear in various views like the home page or an interior page.

Theme Rules also describe the appearance of modules, i.e., colors, images, etc, by way of visual themes. Not every project has the requirement of themes, but some examples might be: personal skin for an applicaton, client branding for a hosted site, holiday or seasonal themes for a News page.

Naming Conventions

In his book, Jonathan Snook covers naming conventions within their respective categories. However, I found this to be such an integral part SMACSS (as it is in OOCSS and BEM), that I wanted to cover it separately. The naming has much to do with the portability and reusability of the styles. It should be independent of page context, yet extend the semantic value of the content it addresses.

In the base rules, because we are dealing with element selectors, there are no names to author. In the other categories, we will see the pattern of prefix-name-extender to help us name the various classes.

Layout rules are prefixed with "l-", for "layout". They should describe the major components they are styling or sections they are dividing. Class names like ".l-header", ".l-content", ".l-footer" are all examples of naming by major section. If you are implementing a grid framework, it might be advantageous to refactor the class names to reflect the SMACSS naming convention (although admittedly, even with an extened find/replace, it can be a bit of work). You may also create helper classes. 

In a current build that I am working on, I am using ".l-row-(extender)", "l.-col-(extender)", and ".l-box-(extender)" for any container that cannot be addressed with grid classes but needs padding to adjust the content layout. The (extender) in this case describes the padding value, but in an indirect manner. I stairstep the extenders with "-cls" (close), "-std" (standard), "-wd" (wide), "-xtr" (extra), and "-spr" (super). If I were to and on one more, it might be called "-dpr" (duper) or "-ult" (ultra). Notice that the actual padding value is not addressed, "-cls" could have a padding of 5px, 10px, whatever. You can go in and change the values within the CSS file without touching the markup. As long as the team you are working with understands the convention, you are golden! 

In this-or-that cases, I borrow from Nicole Sullivan's OOCSS conventions and simply append with "-ext" (extended). An example of this would be ".l-inline" and ".l-inline-ext", where ".l-inline { float: left; display: inline-block; }" and ".l-inline-ext { float: right; display: inline-block; }" in order to manipulate placement within the page while having the neighboring items respect it's top and bottom margins. A variation of this might use text-align: instead of float:. ***TEST THIS***

Modules... Ah, the modules. Because they will be many, no prefix is used for naming them, simple the base name of the module itself and any necessary extender. Think about the function or purpose of the module and how the user will interact with it. The key is to keep the name independent of the page context. Assume that you will use this module several times throughout the site. Are there cases where the module is simple a one-off? Yes, I believe in most projects they are unavoidable, but don't let that prevent you from naming them with portability in mind.

I great example of a module would be the ".btn" module. It is probably safe to say that, when a button or button-like object is used in a project, the look will probably be the same (or should be). Rounded corners, gradient, drop shadow, some characteristic that will be shared regardles of the use context. These rules should be declared on the base class of ".btn". From there, if we need the color to differ according to context, we can create a subclass by using the base name ".btn" plus an extender like "-cta", and apply both of these classes to the item being styled. Note: In this example, I include styles to address use on the <button> or <input type="button" /> where additional default styles need to be considered in order to maintain a consistent look.

It is easy to imagine that we could quickly become inflicted with "classitis" if we are not careful, so the general rule of thumb that I use is Limit of Three. If I find myself using more than three classes to style an element in the markup, I take that as a sign that I may need to break out a separate class or subclass in order to accomplish the look that I am trying to achieve. 